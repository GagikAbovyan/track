//
// System.Buffer.cs
//
// Authors:
//   Paolo Molaro (lupus@ximian.com)
//   Dan Lewis (dihlewis@yahoo.co.uk)
//
// (C) 2001 Ximian, Inc.  http://www.ximian.com
//
import { Base, typeGetValue, markType } from "./type";
import { ArgumentNullException } from "./ArgumentNullException";
import { ArgumentException } from "./ArgumentException";
import { ArgumentOutOfRangeException } from "./ArgumentOutOfRangeException";
export class Buffer extends Base {
    static b(a) {
        try {
        }
        catch (b) {
        }
        if (a == null) {
            throw new ArgumentNullException(0, "array");
        }
        let c = a.length;
        if (c < 0) {
            throw new ArgumentException(1, "Object must be an array of primitives.");
        }
        return c;
    }
    static a(a, b) {
        if (b < 0 || b >= Buffer.b(a)) {
            throw new ArgumentOutOfRangeException(2, "index", "Value must be non-negative and less than the size of the collection.");
        }
        return typeGetValue(a[b]);
    }
    static d(a, b, c) {
        if (b < 0 || b >= Buffer.b(a)) {
            throw new ArgumentOutOfRangeException(2, "index", "Value must be non-negative and less than the size of the collection.");
        }
        a[b] = c;
    }
    static c(a, b, c, d, e) {
        if (a == null) {
            throw new ArgumentNullException(0, "src");
        }
        if (c == null) {
            throw new ArgumentNullException(0, "dst");
        }
        if (b < 0) {
            throw new ArgumentOutOfRangeException(2, "srcOffset", "Non-negative number required.");
        }
        if (d < 0) {
            throw new ArgumentOutOfRangeException(2, "dstOffset", "Non-negative number required.");
        }
        if (e < 0) {
            throw new ArgumentOutOfRangeException(2, "count", "Non-negative number required.");
        }
        if ((b > Buffer.b(a) - e) || (d > Buffer.b(c) - e)) {
            throw new ArgumentException(1, "Offset and length were out of bounds for the array or count is greater than " + "the number of elements from index to the end of the source collection.");
        }
        for (let f = 0; f < e; f++) {
            c[d++] = a[b++];
        }
    }
}
Buffer.$t = markType(Buffer, 'Buffer');
//# sourceMappingURL=Buffer.js.map